// Copyright (c) 2023-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.

package agents

import (
	"encoding/json"
	"fmt"
	"io"
	"strings"

	"github.com/mattermost/mattermost-plugin-ai/llm"
	"github.com/mattermost/mattermost/server/public/model"
)

const defaultMaxFileSize = int64(1024 * 1024 * 5) // 5MB
const UnsafeLinksPostProp = "unsafe_links"

func (p *AgentsService) modifyPostForBot(botid string, requesterUserID string, post *model.Post, respondingToPostID string) {
	post.UserId = botid
	post.Type = "custom_llmbot" // This must be the only place we add this type for security.
	post.AddProp(LLMRequesterUserID, requesterUserID)
	// This tags that the post has unsafe links since they could have been generated by a prompt injection.
	// This will prevent the server from making OpenGraph requests and markdown images being rendered.
	post.AddProp(UnsafeLinksPostProp, "true")

	// Add the ID of the post we're responding to
	if respondingToPostID != "" {
		post.AddProp(RespondingToProp, respondingToPostID)
	}
}

func (p *AgentsService) botCreateNonResponsePost(botid string, requesterUserID string, post *model.Post) error {
	p.modifyPostForBot(botid, requesterUserID, post, "")

	if err := p.pluginAPI.Post.CreatePost(post); err != nil {
		return err
	}

	return nil
}

func (p *AgentsService) botDMNonResponse(botid string, userID string, post *model.Post) error {
	p.modifyPostForBot(botid, userID, post, "")

	if err := p.pluginAPI.Post.DM(botid, userID, post); err != nil {
		return fmt.Errorf("failed to post DM: %w", err)
	}

	return nil
}

func isImageMimeType(mimeType string) bool {
	return strings.HasPrefix(mimeType, "image/")
}

func (p *AgentsService) PostToAIPost(bot *Bot, post *model.Post) llm.Post {
	var filesForUpstream []llm.File
	message := FormatPostBody(post)
	var extractedFileContents []string

	maxFileSize := defaultMaxFileSize
	if bot.cfg.MaxFileSize > 0 {
		maxFileSize = bot.cfg.MaxFileSize
	}

	for _, fileID := range post.FileIds {
		fileInfo, err := p.pluginAPI.File.GetInfo(fileID)
		if err != nil {
			p.pluginAPI.Log.Error("Error getting file info", "error", err)
			continue
		}

		// Check for files that have been interpreted already by the server or are text files.
		content := ""
		if trimmedContent := strings.TrimSpace(fileInfo.Content); trimmedContent != "" {
			content = trimmedContent
		} else if strings.HasPrefix(fileInfo.MimeType, "text/") {
			file, err := p.pluginAPI.File.Get(fileID)
			if err != nil {
				p.pluginAPI.Log.Error("Error getting file", "error", err)
				continue
			}
			contentBytes, err := io.ReadAll(io.LimitReader(file, maxFileSize))
			if err != nil {
				p.pluginAPI.Log.Error("Error reading file content", "error", err)
				continue
			}
			content = string(contentBytes)
			if int64(len(contentBytes)) == maxFileSize {
				content += "\n... (content truncated due to size limit)"
			}
		}

		if content != "" {
			fileContent := fmt.Sprintf("File Name: %s\nContent: %s", fileInfo.Name, content)
			extractedFileContents = append(extractedFileContents, fileContent)
		}

		if bot.cfg.EnableVision && isImageMimeType(fileInfo.MimeType) {
			file, err := p.pluginAPI.File.Get(fileID)
			if err != nil {
				p.pluginAPI.Log.Error("Error getting file", "error", err)
				continue
			}
			filesForUpstream = append(filesForUpstream, llm.File{
				Reader:   file,
				MimeType: fileInfo.MimeType,
				Size:     fileInfo.Size,
			})
		}
	}

	// Add structured file contents to the message
	if len(extractedFileContents) > 0 {
		message += "\nAttached File Contents:\n" + strings.Join(extractedFileContents, "\n\n")
	}

	role := llm.PostRoleUser
	if p.IsAnyBot(post.UserId) {
		role = llm.PostRoleBot
	}

	// Check for tools
	pendingToolsProp := post.GetProp(ToolCallProp)
	tools := []llm.ToolCall{}
	pendingTools, ok := pendingToolsProp.(string)
	if ok {
		var toolCalls []llm.ToolCall
		if err := json.Unmarshal([]byte(pendingTools), &toolCalls); err != nil {
			p.pluginAPI.Log.Error("Error unmarshalling tool calls", "error", err)
		} else {
			tools = toolCalls
		}
	}

	return llm.Post{
		Role:    role,
		Message: message,
		Files:   filesForUpstream,
		ToolUse: tools,
	}
}

func (p *AgentsService) ThreadToLLMPosts(bot *Bot, posts []*model.Post) []llm.Post {
	result := make([]llm.Post, 0, len(posts))

	for _, post := range posts {
		result = append(result, p.PostToAIPost(bot, post))
	}

	return result
}

func FormatPostBody(post *model.Post) string {
	attachments := post.Attachments()
	if len(attachments) > 0 {
		result := strings.Builder{}
		result.WriteString(post.Message)
		for _, attachment := range attachments {
			result.WriteString("\n")
			if attachment.Pretext != "" {
				result.WriteString(attachment.Pretext)
				result.WriteString("\n")
			}
			if attachment.Title != "" {
				result.WriteString(attachment.Title)
				result.WriteString("\n")
			}
			if attachment.Text != "" {
				result.WriteString(attachment.Text)
				result.WriteString("\n")
			}
			for _, field := range attachment.Fields {
				value, err := json.Marshal(field.Value)
				if err != nil {
					continue
				}
				result.WriteString(field.Title)
				result.WriteString(": ")
				result.Write(value)
				result.WriteString("\n")
			}

			if attachment.Footer != "" {
				result.WriteString(attachment.Footer)
				result.WriteString("\n")
			}
		}
		return result.String()
	}
	return post.Message
}
